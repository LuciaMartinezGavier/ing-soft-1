# ‚úèÔ∏è Dise√±o del software
+ Se realiza luego de que los requerimientos est√©n definidos y antes de la implementaci√≥n.
+ Es el lenguaje intermedio entre los requerimientos y el c√≥digo.
+ Se comienzan a hacer representaciones m√°s concretas.
+ El resultado es un plano del sistema que **satisfaga los requerimientos** y que se utilizar√° para la implementaci√≥n.
+ Determina las mayores caracter√≠sticas de un sistema.
+ Tiene un gran **impacto en testing** y **mantenimiento**.

Lo ideal es que sea **simple** y **entendible**.

## üëæ Niveles en el proceso
1. Dise√±o arquitect√≥nico:
	+ Identifica las componentes necesarias del sistema, su comportamiento y relaciones.
1. **Dise√±o de alto nivel**:
	* Es la vista de los m√≥dulos del sistema.
	* Cu√°les son los m√≥dulos del sistema, qu√© deben hacer, y c√≥mo se organizan/interconectan
	* Opciones:
		* [Orientado a funciones](#dise√±o-orientado-a-funciones)
		* [Orientado a objetos](#dise√±o-orientado-a-objetos)
2. Dise√±o detallado o dise√±o l√≥gico:
	+ Establece *c√≥mo* se implementan las componentes de manera que satisfagan sus especificaciones.
	+ Muy cercano al c√≥digo: incluye detalles del procesamiento l√≥gico (por ejemplo algoritmo) y de estructuras de datos.

## ü¶â Criterios para Evaluar el Dise√±o
<!-- SE EVAL√öA -->
Los criterios son usualmente subjetivos y no cuantificables. :(  
Principales criterios para evaluar:  
1. **Correcci√≥n** üëçüèº
	+ ¬øEl dise√±o implementa todos los *requerimientos*?
	+ ¬øEs *factible* el dise√±o dada las restricciones?

2. **Eficiencia** üèÉüèº‚Äç‚ôÄÔ∏è
	* Apropiado *uso de los recursos* del sistema (principalemte CPU y memoria).

3. **Simplicidad**  üßòüèº‚Äç‚ôÄ
	<!-- Las cosas simples son dif√≠ciles de hacer, f√°ciles de entender. -->
	+ Facilita la *comprensi√≥n* del sistema.
	* Facilita el testing, modificaci√≥n de c√≥digo, mantenimiento, descubrimiento y correcci√≥n de bugs. ü¶Ñüåà

Eficiencia y simplicidad no son independientes => el dise√±ador debe encontrar un balance.

## üê¶ Principios de dise√±o
No hay una serie de pasos que permitan derivar el dise√±o a partir de los requerimientos. Pero existen "ayudas" que son **principios fundamentales** que gu√≠an el proceso de dise√±o:

### ü™Ü Partici√≥n y jerarqu√≠a.
Consiste en dividir el problema en peque√±as partes, simplificando el dise√±o y facilitando el mantenimiento. Cada parte debe poder *solucionarse*  y *modificarse* independientemente. Aunque no son totalmente independientes: deben **comunicarse** para solucionar el problema mayor.

La comunicaci√≥n agrega complejidad: A medida que la cantidad de componentes aumenta, el *costo del particionado* + la *complejidad de la comunicaci√≥n* tambi√©n aumenta. Hay que detener el particionado cuando el costo supera al beneficio.

El particionado del problema determina una *jerarqu√≠a* de componentes en el dise√±o. Usualmente la jerarqu√≠a se forma a partir de la relaci√≥n "es parte de".

La abstracci√≥n es esencial en el particionado del problema, pues `Jerarqu√≠a => Abstracci√≥n` aunque no necesariamente se cumple `Abstracci√≥n => Jerarqu√≠a`.

### üé® Abstracci√≥n
La abstracci√≥n de una componente describe el *comportamiento externo* sin dar detalles internos de c√≥mo se produce dicho comportamiento. Es decir, trata de *ocultar* detalles de lo que pasa en niveles m√°s bajos.

Abstracci√≥n durante el proceso de dise√±o:
+ Para decidir como interact√∫an las componentes s√≥lo el comportamiento externo es relevante. 
+ Permite concentrarse en una componente a la vez.
+ Permite considerar una componente sin preocuparse por las otras.
+ Permite que el dise√±ador controle la complejidad.
+ Permite una transici√≥n gradual de lo m√°s abstracto a lo m√°s concreto.
+ Necesaria para solucionar las partes separadamente.

**Mecanismos comunes de abstracci√≥n**  
1. *Abstracci√≥n funcional*
	+ Especifica el comportamiento funcional de un m√≥dulo.
	+ Los m√≥dulos se tratan como funciones de entrada/salida.
	+ Puede especificarse usando pre y post condiciones.
3. *Abstracci√≥n de datos*
	+ Una entidad del mundo que provee servicios al entrono.
	+ Los datos se tratan como objetos junto a sus operaciones (orientaci√≥n a objetos). Y las operaciones definidas para un objetos solo pueden realizarse sobre este objeto.
	+ Lenguajes que soportan abstracci√≥n de datos: Ada, C++, Modula, Java

### üì¶ Modularidad
Un sistema se dice modular si consiste de *componentes discretas*  que se pueden *implementar separadamente*; donde un cambio a una de ellas tenga *m√≠nimo impacto* sobre las otras.

+ Prove la abstracci√≥n en el software.
+ Es el soporte de la estructura jer√°rquica de los programas.
+ Mejora claridad de dise√±o y facilita la implementaci√≥n.
+ Reduce costos de testing, debugging y mantenimiento.

Necesita *criterios de descomposici√≥n*: resulta de la conjunci√≥n de la *abstracci√≥n* y el *particionado*.

### ‚§µÔ∏è Estrategias top-down y bottom-up‚§¥Ô∏è 
Enfoques para dise√±ar la jerarqu√≠a de componentes.

**Top-down:**
+ El *refinamiento* de m√°s general a m√°s especifico. Hasta que pueda ser implementado directamente.
+ Ventaja: En cada paso existe una clara imagen del dise√±o.
+ Desventaja: se puede asumir que un m√≥dulo se pueda hacer pero al final no sea posible: *factibilidad desconocida* hasta el final.

**Bottom-up**:
+ Comienza por las componentes de m√°s bajo nivel en la jerarqu√≠a.
+ Se usa cuando hay mucho re-uso.

# üêú Dise√±o orientado a funciones

## M√≥dulos
Un m√≥dulo es una **parte l√≥gicamente** separable de un programa.
Es una unidad **discreta** e **identificable**.

Criterios para seleccionar m√≥dulos que soporten abstracciones bien definidas: acoplamiento y cohesi√≥n.

<!-- SE EVAL√öA SIEMPRE -->
### Acoplamiento
#### Definici√≥n
El acoplamiento es un concepto *inter-modular*, que determina la forma y nivel de *dependencia* entre m√≥dulos.

**Dos m√≥dulos son independientes si cada uno puede funcionar completamente sin la presencia del otro**.

El nivel de acoplamiento se define a nivel de dise√±o arquitect√≥nico y de alto nivel. Y no puede reducirse durante la implementaci√≥n.

#### Ventajas de la independencia
Los m√≥dulos se pueden implementar, modificar y testear separadamente.

No es necesario comprender todos los m√≥dulos para comprender uno en particular: Cuanto m√°s conexiones hay entre dos m√≥dulos, m√°s dependientes son uno del otro, es decir, se requiere m√°s conocimiento de un m√≥dulo para comprender el otro.

#### Objetivo
Los m√≥dulos deben estar tan *d√©bilmente acoplados* como sea posible.

En un sistema *no existe la independencia entre todos los m√≥dulos* pues deben cooperar entre s√≠. Pero queremos que la dependencia sea m√≠nima.

#### Factores que influyen en el acoplamiento
1. **Tipo de conexiones entre m√≥dulos**: La *complejidad* y *oscuridad* de las interfaces. Ejemplo: ¬øUtilizo solo las interfaces especificadas o tambi√©n uso datos compartidos?
2. **Complejidad de las interfaces**: ¬øEstoy pasando solo los par√°metros necesarios? De todas maneras, cierto nivel de complejidad en las interfaces es necesario para soportar la comunicaci√≥n requerida con el m√≥dulo.
3. **Tipo de flujo de informaci√≥n entre m√≥dulos**: ¬øEstoy pasando par√°metros de control (flags)? si se pasan flags que determinan el un caso de la funci√≥n, es probable que se pueda dividir en dos funciones. Transferencia de informaci√≥n de control permite que las acciones de los m√≥dulos dependan de la informaci√≥n; y hace que los m√≥dulos sean m√°s dif√≠ciles de comprender. 

**El acoplamiento disminuye si**: 
+ Solo las  entradas definidas en un m√≥dulo son utilizadas por los otros.
+ La informaci√≥n se pasa exclusivamente a trav√©s de par√°metros.
+ S√≥lo se pasa la informaci√≥n estrictamente necesaria.
+ Las interfaces solo contienen comunicaci√≥n de datos.

**El acoplamiento se incrementa si**:  
+ Se utilizan interfaces indirectas y oscuras.
+ Se usan directamente operaciones y atributos internos al m√≥dulo
+ Se utilizan variables compartidas.
+ Se pasan par√°metros que contienen m√°s informaci√≥n de la necesaria y hay que parsear (depende del formato).
+ Las interfaces contienen comunicaci√≥n de informaci√≥n h√≠brida (datos+control).

### Cohesi√≥n
#### Definici√≥n
Es *intra-modular*. Tiene que ver con la relaci√≥n de las componentes del mismo m√≥dulo. Y determina cu√°n fuertemente *vinculados* est√°n los elementos de un m√≥dulo.

Consiste en minimizar las relaciones entre los elementos de los distintos m√≥dulos y maximizando las relaciones entre los elementos del mismo m√≥dulo.

#### Objetivo
Alta cohesi√≥n. Usualmente, a mayor cohesi√≥n de los m√≥dulos, menor acoplamiento.

#### Tipos de cohesi√≥n
<!--m√°s d√©bil-->
1. **Casual**: La relaci√≥n entre los elementos del m√≥dulo no tiene significado.
2. **L√≥gica**: Existe alguna relaci√≥n l√≥gica entre los elementos del m√≥dulo; los elementos realizan funciones dentro de la misma clase l√≥gica.
3. **Temporal**: Los elementos est√°n relacionados en el tiempo y se ejecutan juntos. Ejemplo: inicializaci√≥n, clean-up, finalizaci√≥n.
4. **Procedural**: Contiene elementos que pertenecen a una misma unidad procedural. Ejemplo: un ciclo o secuencia de decisiones.
5. **Comunicacional**: Tiene elementos que est√°n relacionados por una referencia al mismo datos. Ejemplo: pedir los datos de una cuenta personal y devolver todos los datos del registro.
6. **Secuencial**: Los elementos est√°n juntos porque la salida de uno corresponde a la entrada del otro. Es relativamente buena cohesi√≥n y relativamente f√°cil de mantener, pero dif√≠cil de reusar.
7. **Funcional**: Todos los elementos del m√≥dulo est√°n relacionados para llevar a cabo una sola funci√≥n. Ejemplo: Calcular el seno de un √°ngulo.
<!-- m√°s fuerte -->

#### Determinar la cohesi√≥n de un m√≥dulo.
<!-- No se toma -->
Describir el prop√≥sito del m√≥dulo con una *oraci√≥n*.
Realizar el siguiente test:
+ Si la **oraci√≥n es compuesta**, tiene **comas** o m√°s de un verbo => el m√≥dulo est√° probablemente realizando m√°s de una funci√≥n. Probablemente tenga cohesi√≥n *secuencial* o *comunicacional*.
+ Si la oraci√≥n contiene **palabras relacionadas al tiempo** (ejemplo: primero, luego, cuando, despu√©s) => probablemente el m√≥dulo tenga cohesi√≥n *secuencial* o *temporal*. 
+ Si el predicado **no contiene un √∫nico objeto espec√≠fico** a continuaci√≥n del verbo (como es el caso de ‚Äúeditar los datos‚Äù) => probablemente tenga cohesi√≥n *l√≥gica*.
+ Palabras como **inicializar/limpiar/...** implican cohesi√≥n *temporal*.

Los m√≥dulos funcionalmente cohesivos siempre pueden describirse con una **oraci√≥n simple**.


## Notaci√≥n y especificaci√≥n del dise√±o
Nos interesan el **dise√±o del sistema** (el producto de la fase) y  el **proceso** que lleva a cabo el dise√±o.

### Diagramas de estructura
Presenta una notaci√≥n gr√°fica para la *estructura de un programa*.
Representa m√≥dulos y sus interconexiones. Se puede realizar una correlaci√≥n entre c√≥digo y diagramas de estructura.

La invocaci√≥n de A a B se representa con una flecha; cada flecha se etiqueta con los √≠tems que se pasan.

**Tipos de m√≥dulos**:  
![](https://imgur.com/iqWOFcl.png)

**Iteraci√≥n y decisi√≥n**
![](https://imgur.com/wepHQQy.png)

No es intenci√≥n de los diagramas de estructura mostrar la l√≥gica del programa. Solo se indican las m√°s importantes.

## Metodolog√≠a del dise√±o estructurado
La estructura se decide durante el dise√±o y la implementaci√≥n NO debe cambiar la estructura. La metodolog√≠a de dise√±o estructurado (SDM: *Structured Design Method*) apunta a controlar la estructura y proveer pautas para auxiliar al dise√±ador en el proceso de dise√±o. SDM es una metodolog√≠a orientada a funciones.

### Pautas
+ Los m√≥dulos *subordinados* son los que realizan la mayor√≠a de la computaci√≥n. El procesamiento real se realiza en los m√≥dulos *at√≥micos* del nivel m√°s bajo.
+ El m√≥dulo *principal* se encarga de la coordinaci√≥n.
+ La *factorizaci√≥n* es el proceso de descomponer un m√≥dulo de manera que el grueso de la computaci√≥n se realice en m√≥dulos subordinados.

### Pasos principales
1. [Reformular el problema como un DFD](#reformular-el-problema-como-un-DFD)
2. [Identificar las entradas y salidas m√°s abstractas](#identificar-las-entradas-y-salidas-abstractas)
3. [Realizar el primer nivel de factorizaci√≥n](#factorizar1)
4. [Factorizar los m√≥dulos de entrada, de salida, y transformadores](#factorizar2)
5. [Mejorar la estructura (heur√≠sticas, an√°lisis de transacciones)](#mejorar-la-estructura)

#### Reformular el problema como un DFD
#### Identificar las entradas y salidas abstractas
#### Factorizar1
#### Factorizar2
#### Mejorar la estructura

## Verificaci√≥n

## M√©tricas

# Dise√±o orientado a objetos